//! NVIDIA Management Library (NVML) Confidential Computing Module
//!
//! This module provides functionality for interacting with NVIDIA GPUs to obtain
//! attestation reports for confidential computing. It handles both synchronous and
//! asynchronous fetching of attestation reports, which are used to verify the
//! integrity and authenticity of GPU hardware and its execution environment.
//!
//! The attestation reports can be used in remote attestation protocols to establish
//! trust with external services or validators.

use nscq::NscqHandler;
use nvml_wrapper::Nvml;
use remote_attestation_verifier::errors::NscqError;

/// The size of the nonce used for the attestation report
const NONCE_SIZE: usize = 32;

/// The result type for the NVML Confidential Computing module
type Result<T> = std::result::Result<T, AttestationError>;

/// Checks if confidential computing is supported on the specified GPU device
///
/// This function queries the NVML library to determine whether the GPU at the given
/// device index supports confidential computing features. This is useful for
/// determining if attestation reports can be generated from this device.
///
/// # Arguments
///
/// * `device_index` - The index of the NVIDIA GPU device to check
///
/// # Returns
///
/// * `bool` - `true` if confidential computing is supported, `false` otherwise
///
/// # Errors
///
/// * `AttestationError::NvmlError` - If the NVML library returns an error
pub fn check_confidential_compute_status(device_index: u32) -> Result<bool> {
    let nvml = Nvml::init()?;
    let device = nvml.device_by_index(device_index)?;
    Ok(device.check_confidential_compute_status()?)
}

/// Fetch the attestation report for a given device index and nonce
///
/// This function performs a blocking call to the NVML library to retrieve an
/// attestation report from the specified GPU device. The nonce is used to ensure
/// freshness of the attestation report and prevent replay attacks.
///
/// # Arguments
///
/// * `index` - The index of the device to fetch the attestation report for
/// * `nonce` - The nonce to use for the attestation report (typically a cryptographic challenge)
///
/// # Returns
///
/// * `Vec<u8>` - The raw attestation report for the given device index and nonce
///
/// # Errors
///
/// * `AttestationError::NvmlError` - If the NVML library returns an error
/// * `AttestationError::InvalidDeviceIndex` - If the device index cannot be converted to u32
pub fn fetch_attestation_report(index: u32, nonce: [u8; NONCE_SIZE]) -> Result<Vec<u8>> {
    let nvml = Nvml::init()?;
    let device = nvml.device_by_index(index)?;
    let report = device.confidential_compute_gpu_attestation_report(nonce)?;
    let attestation_report_size = report.attestation_report_size as usize;
    let report_bytes = report.attestation_report[0..attestation_report_size].to_vec();
    Ok(report_bytes)
}

/// Fetch the attestation report for a given device index and nonce asynchronously,
/// using a blocking call to avoid blocking the main thread.
///
/// This function offloads the blocking NVML operation to Tokio's dedicated thread pool
/// for CPU-bound tasks, allowing the caller to continue processing other async tasks
/// while waiting for the attestation report.
///
/// # Arguments
///
/// * `index` - The index of the device to fetch the attestation report for
/// * `nonce` - The nonce to use for the attestation report (typically a cryptographic challenge)
///
/// # Returns
///
/// * `Vec<u8>` - The raw attestation report for the given device index and nonce
///
/// # Errors
///
/// * `AttestationError::NvmlError` - If the NVML library returns an error
/// * `AttestationError::InvalidDeviceIndex` - If the device index cannot be converted to u32
/// * `AttestationError::JoinError` - If the spawned blocking task fails to complete
pub async fn fetch_attestation_report_async(
    index: u32,
    nonce: [u8; NONCE_SIZE],
) -> Result<Vec<u8>> {
    let join_handle = tokio::task::spawn_blocking(move || fetch_attestation_report(index, nonce));
    join_handle.await?
}

/// Fetch the certificate chain for a given device index
///
/// This function performs a blocking call to the NVML library to retrieve the
/// certificate chain from the specified GPU device. The certificate chain is used
/// to verify the authenticity of attestation reports generated by the device.
///
/// # Arguments
///
/// * `index` - The index of the device to fetch the certificate chain for
///
/// # Returns
///
/// * `Result<Vec<u8>>` - The raw certificate chain data for the given device
///
/// # Errors
///
/// * `AttestationError::NvmlError` - If the NVML library returns an error
/// * `AttestationError::InvalidDeviceIndex` - If the device index cannot be converted to u32
pub fn fetch_device_certificate_chain(index: u32) -> Result<Vec<u8>> {
    let nvml = Nvml::init()?;
    let device = nvml.device_by_index(index)?;
    let certificate = device.confidential_compute_gpu_certificate()?;
    let attestation_certificate_size = certificate.attestation_cert_chain_size as usize;
    let attestation_certificate_bytes =
        certificate.attestation_cert_chain[0..attestation_certificate_size].to_vec();
    Ok(attestation_certificate_bytes)
}

/// Fetch the certificate chain for a given device index asynchronously,
/// using a blocking call to avoid blocking the main thread.
///
/// This function offloads the blocking NVML operation to Tokio's dedicated thread pool
/// for CPU-bound tasks, allowing the caller to continue processing other async tasks
/// while waiting for the certificate chain.
///
/// # Arguments
///
/// * `index` - The index of the device to fetch the certificate chain for
///
/// # Returns
///
/// * `Result<Vec<u8>>` - The raw certificate chain data for the given device
///
/// # Errors
///
/// * `AttestationError::NvmlError` - If the NVML library returns an error
/// * `AttestationError::InvalidDeviceIndex` - If the device index cannot be converted to u32
/// * `AttestationError::JoinError` - If the spawned blocking task fails to complete
pub async fn fetch_device_certificate_chain_async(index: u32) -> Result<Vec<u8>> {
    let join_handle = tokio::task::spawn_blocking(move || fetch_device_certificate_chain(index));
    join_handle.await?
}

/// Get the number of devices supported by the NVML library
///
/// This function queries the NVML library to determine the number of devices
/// supported by the system. It returns the count of devices as an unsigned integer.
///
/// # Returns
///
/// * `Result<usize>` - The number of devices supported by the NVML library
///
/// # Errors
///
/// * `AttestationError::NvmlError` - If the NVML library returns an error
pub fn num_devices() -> Result<u32> {
    let nvml = Nvml::init()?;
    let num_devices = nvml.device_count()?;
    Ok(num_devices)
}

/// Get the confidential compute ready state for a given device index
///
/// This function queries the NVML library to determine the confidential compute
/// ready state for a given device index.
///
/// # Returns
///
/// * `Result<bool>` - The confidential compute ready state for the given device index
///
/// # Errors
///
/// * `AttestationError::NvmlError` - If the NVML library returns an error
pub fn get_cc_ready_state(index: u32) -> Result<bool> {
    let nvml = Nvml::init()?;
    let device = nvml.device_by_index(index)?;
    let cc_ready_state = device.get_confidential_compute_state()?;
    Ok(cc_ready_state)
}

/// Set the confidential compute ready state for a given device index
///
/// This function queries the NVML library to determine the confidential compute
/// ready state for a given device index.
///
/// # Returns
///
/// * `Result<bool>` - The confidential compute ready state for the given device index
///
/// # Errors
///
/// * `AttestationError::NvmlError` - If the NVML library returns an error
pub fn set_cc_ready_state(index: u32, is_accepting_work: bool) -> Result<()> {
    let nvml = Nvml::init()?;
    let device = nvml.device_by_index(index)?;
    device.set_confidential_compute_state(is_accepting_work)?;
    Ok(())
}

/// Check if multi-GPU protected PCIe is enabled
///
/// This function checks if multi-GPU protected PCIe is enabled on the system.
/// It returns `true` if multi-GPU protected PCIe is enabled, otherwise it returns `false`.
///
/// # Returns
///
/// * `Result<bool>` - `true` if multi-GPU protected PCIe is enabled, `false` otherwise
///
/// # Errors
///
/// * `AttestationError::NvmlError` - If the NVML library returns an error
pub fn is_multi_gpu_protected_pcie_enabled(index: u32) -> Result<bool> {
    let nvml = Nvml::init()?;
    let device = nvml.device_by_index(index)?;
    Ok(device.is_multi_gpu_protected_pcie_enabled()?)
}

/// Get all NVSwitch UUIDs
///
/// This function queries the NSCQ library to retrieve all NVSwitch UUIDs.
///
/// # Returns
///
/// * `Result<Vec<String>>` - The list of all NVSwitch UUIDs
///
/// # Errors
///
/// * `AttestationError::NscqError` - If the NSCQ library returns an error
pub fn get_nvswitch_uuid() -> Result<Vec<String>> {
    let nscq = NscqHandler::new().map_err(|e| AttestationError::NscqError(NscqError::from(e)))?;
    nscq.get_all_switch_uuid()
        .map_err(|e| AttestationError::NscqError(NscqError::from(e)))
}

/// Fetch the attestation report for a given NVSwitch UUID asynchronously,
/// using a blocking call to avoid blocking the main thread.
///
/// This function offloads the blocking NVML operation to Tokio's dedicated thread pool
/// for CPU-bound tasks, allowing the caller to continue processing other async tasks
/// while waiting for the attestation report.
///
/// # Arguments
///
/// * `nonce` - The nonce to use for the attestation report (typically a cryptographic challenge)
///
/// # Returns
///
/// * `Result<Vec<Vec<u8>>>` - The raw attestation report for all the NvSwitches
///
/// # Errors
///
/// * `AttestationError::NvmlError` - If the NVML library returns an error
pub fn fetch_nvswitch_attestation_report(nonce: [u8; NONCE_SIZE]) -> Result<Vec<Vec<u8>>> {
    let nscq = NscqHandler::new().map_err(|e| AttestationError::NscqError(NscqError::from(e)))?;
    let report = nscq
        .get_all_switch_attestation_report(&nonce)
        .map_err(|e| AttestationError::NscqError(NscqError::from(e)))?;
    Ok(report.values().map(|v| v.to_vec()).collect())
}

/// Fetch the attestation report for a given NVSwitch UUID asynchronously,
/// using a blocking call to avoid blocking the main thread.
///
/// This function offloads the blocking NVML operation to Tokio's dedicated thread pool
/// for CPU-bound tasks, allowing the caller to continue processing other async tasks
/// while waiting for the attestation report.
///
/// # Arguments
///
/// * `nonce` - The nonce to use for the attestation report (typically a cryptographic challenge)
///
/// # Returns
///
/// * `Result<Vec<Vec<u8>>>` - The raw attestation report for all the NvSwitches
///
/// # Errors
///
/// * `AttestationError::NvmlError` - If the NVML library returns an error
/// * `AttestationError::JoinError` - If the spawned blocking task fails to complete
pub async fn fetch_nvswitch_attestation_report_async(
    nonce: [u8; NONCE_SIZE],
) -> Result<Vec<Vec<u8>>> {
    let join_handle = tokio::task::spawn_blocking(move || fetch_nvswitch_attestation_report(nonce));
    join_handle.await?
}

/// Fetch the certificate chain for a given NVSwitch UUID
///
/// This function queries the NSCQ library to retrieve the certificate chain for a given NVSwitch UUID.
///
/// # Arguments
///
/// * `uuid` - The UUID of the NVSwitch to fetch the certificate chain for
///
/// # Returns
///
/// * `Result<Vec<Vec<u8>>>` - The raw certificate chain data for all the NvSwitches
///
/// # Errors
///
/// * `AttestationError::NscqError` - If the NSCQ library returns an error
pub fn fetch_nvswitch_certificate_chain() -> Result<Vec<Vec<u8>>> {
    let nscq = NscqHandler::new().map_err(|e| {
        AttestationError::NscqError(remote_attestation_verifier::errors::NscqError::from(e))
    })?;
    let certificates = nscq
        .get_all_switch_attestation_certificate_chain()
        .map_err(|e| {
            AttestationError::NscqError(remote_attestation_verifier::errors::NscqError::from(e))
        })?;
    Ok(certificates.values().cloned().collect())
}

/// Fetch the certificate chain for a given NVSwitch UUID asynchronously,
/// using a blocking call to avoid blocking the main thread.
///
/// This function offloads the blocking NVML operation to Tokio's dedicated thread pool
/// for CPU-bound tasks, allowing the caller to continue processing other async tasks
/// while waiting for the certificate chain.
///
/// # Arguments
///
/// * `uuid` - The UUID of the NVSwitch to fetch the certificate chain for
///
/// # Returns
///
/// * `Result<Vec<Vec<u8>>>` - The raw certificate chain data for all the NvSwitches
///
/// # Errors
///
/// * `AttestationError::NscqError` - If the NSCQ library returns an error
pub async fn fetch_nvswitch_certificate_chain_async() -> Result<Vec<Vec<u8>>> {
    let join_handle = tokio::task::spawn_blocking(fetch_nvswitch_certificate_chain);
    join_handle.await?
}

#[derive(Debug, thiserror::Error)]
pub enum AttestationError {
    #[error("NVML error: {0}")]
    NvmlError(#[from] nvml_wrapper::error::NvmlError),
    #[error("Invalid device index: {0}")]
    InvalidDeviceIndex(#[from] std::num::TryFromIntError),
    #[error("Join error: {0}")]
    JoinError(#[from] tokio::task::JoinError),
    #[error("Nscq error: {0}")]
    NscqError(#[from] remote_attestation_verifier::errors::NscqError),
}
