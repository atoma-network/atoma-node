use crate::ToBytes;

use sev::{
    attestation::{AttestationReport, AttestationReportSignature, Chain},
    error::SevError,
    firmware::Firmware,
};

use thiserror::Error;

pub const SEV_SNP_REPORT_DATA_SIZE: usize = 64;

type Result<T> = std::result::Result<T, SevError>;

/// Generates an SEV-SNP attestation report for the given compute data.
///
/// This function takes a slice of bytes representing the attested data and returns
/// an AttestationReport. The attested data must be exactly 64 bytes long,
/// matching the SEV_SNP_REPORT_DATA_SIZE constant.
///
/// # Arguments
///
/// * `attested_data` - A slice of bytes containing the data to be attested (public key)
///
/// # Returns
///
/// * `Result<AttestationReport>` - On success, returns an AttestationReport.
///                                 On failure, returns a SevError.
///
/// # Errors
///
/// Returns `SevError::InvalidAttestedDataSize` if the input data size is not 64 bytes.
/// Returns `SevError::FailedToOpenFirmware` if the firmware interface cannot be opened.
/// Returns `SevError::FailedToGetAttestationReport` if the attestation report cannot be generated.
///
/// # Example
///
/// ```
/// let data_to_attest = [1u8; 64];
/// match get_compute_data_attestation(&data_to_attest) {
///     Ok(report) => println!("Attestation successful"),
///     Err(e) => eprintln!("Attestation failed: {}", e),
/// }
/// ```
pub fn get_compute_data_attestation(attested_data: &[u8]) -> Result<SNPAttestationReport> {
    if attested_data.len() != SEV_SNP_REPORT_DATA_SIZE {
        return Err(SevError::InvalidAttestedDataSize(attested_data.len()));
    }

    let mut firmware = Firmware::open().map_err(SevError::FailedToOpenFirmware)?;

    // Message version is set as a protocol version indicator, default is 1.
    let message_version = 1;

    // Virtual Machine Privilege Level, 0 = least privileged, 3 = most privileged.
    // VMPL allows for page security levels in the SNP Guest. 
    // If VMPL is disabled on the platform, set to 0.
    // See: https://docs.enclaive.cloud/confidential-cloud/technology-in-depth/amd-sev/technology/fundamentals/features/virtual-machine-privilege-levels
    let vmpl = 0;

    // Ask the PSP to generate an extended attestation report for the given data as the proxy will need to verify the report.
    let (chain, report): (Chain, AttestationReport) = firmware
        .get_ext_report(Some(message_version), Some(attested_data), Some(vmpl))
        .map_err(SevError::FailedToGetAttestationReport)?;

    let snp_attestation_report = (chain, report).to_snp_attestation_report();

    Ok(snp_attestation_report)
}

/// A wrapper struct for the attestation report and certificate chain received from the SNP_GET_EXT_REPORT ioctl.
#[derive(Debug, Clone)]
pub struct SNPAttestationReport {
    /// The chain of certificates that form the chain of trust for the attestation report.
    pub chain: Chain,
    /// The attestation report generated by the PSP.
    pub report: AttestationReport,
}

/// Trait for converting a tuple of (Chain, AttestationReport) to an SNPAttestationReport.
pub trait ToSNPAttestationReport {
    fn to_snp_attestation_report(&self) -> SNPAttestationReport;
}

impl ToSNPAttestationReport for (Chain, AttestationReport) {
    fn to_snp_attestation_report(&self) -> SNPAttestationReport {
        SNPAttestationReport {
            chain: self.0,
            report: self.1,
        }
    }
}

/// Implements the Verifiable trait (crypto_nossl feature-gated implementation) for SNPAttestationReport.
impl sev::snp::certs::Verifiable for SNPAttestationReport {
    type Output = bool;

    /// Verifies the attestation report against the VCEK certificate.
    /// Taken from: https://docs.rs/sev/5.0.0/src/sev/firmware/guest/types/snp.rs.html#351-391
    fn verify(&self) -> Result<(), SevError> {
        // According to Chapter 3 of the [Versioned Chip Endorsement Key (VCEK) Certificate and
        // KDS Interface Specification][spec], the VCEK certificate certifies an ECDSA public key on curve P-384,
        // and the signature hash algorithm is sha384.
        // [spec]: https://www.amd.com/content/dam/amd/en/documents/epyc-technical-docs/specifications/57230.pdf

        let vcek = self.0.verify()?;
        let sig  = p384::ecdsa::Signature::try_from(&self.1.signature)?;

        let measurable_bytes: &[u8] = &bincode::serialize(self.1).map_err(|e| {
            SevError::FailedVerification(format!("Unable to serialize bytes: {}", e))
        })?[..0x2a0];

        use sha2::Digest;
        let base_digest = sha2::Sha384::new_with_prefix(measurable_bytes);

        let verifying_key = p384::ecdsa::VerifyingKey::from_sec1_bytes(vcek.public_key_sec1())
            .map_err(|e| {
                SevError::FailedVerification(format!("failed to deserialize public key from sec1 bytes: {e:?}"))
            })?;

        use p384::ecdsa::signature::DigestVerifier;
        verifying_key.verify_digest(base_digest, &sig).map_err(|e| {
            SevError::FailedVerification(format!("VCEK does not sign the attestation report: {e:?}"))
        })
    }
}

#[derive(Error, Debug)]
pub enum SevError {
    #[error("Invalid attested data size: expected {}, got {0}", SEV_SNP_REPORT_DATA_SIZE)]
    InvalidAttestedDataSize(usize),
    #[error("Failed to verify attestation report: {0}")]
    FailedVerification(#[source] std::io::Error),
    #[error("Failed to open firmware interface: {0}")]
    FailedToOpenFirmware(#[source] std::io::Error),
    #[error("Failed to get attestation report: {0}")]
    FailedToGetAttestationReport(#[source] std::io::Error),
}
